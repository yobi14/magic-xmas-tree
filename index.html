<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <title>Cyber Xmas 2025</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; touch-action: none; }
        canvas { display: block; filter: contrast(120%) brightness(110%); }
        #overlay {
            position: absolute; bottom: 30px; width: 100%; text-align: center;
            color: #fff; font-family: 'Orbitron', sans-serif; letter-spacing: 5px;
            pointer-events: none; text-shadow: 0 0 20px #0ff; opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="overlay">NEO-CHRISTMAS 2025</div>
    <canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

let W, H;
let particles = [];
const COUNT = 2200; 
const PROJECTION_DIST = 400; 
let rotation = 0;
let mouse = { x: -1000, y: -1000, active: false };

function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
}
window.addEventListener("resize", resize);
resize();

// äº¤äº’ç›‘å¬
const updateMouse = (e) => {
    mouse.x = (e.clientX || e.touches[0].clientX);
    mouse.y = (e.clientY || e.touches[0].clientY);
    mouse.active = true;
};
window.addEventListener("mousemove", updateMouse);
window.addEventListener("touchmove", updateMouse);
window.addEventListener("touchend", () => mouse.active = false);

class Particle {
    constructor(id) {
        this.id = id;
        this.reset();
    }

    reset() {
        this.progress = Math.random(); // 0 æ˜¯åº•éƒ¨ï¼Œ1 æ˜¯é¡¶éƒ¨
        this.angle = this.id * 0.15; // å½¢æˆèºæ—‹
        this.distFromCenter = (1 - this.progress) * 250;
        this.y3d = (this.progress * 500) - 250; // 3D Yåæ ‡
        
        // åŠ¨æ€å±æ€§
        this.hue = this.progress * 100 + 140; // ä»æ·±ç»¿åˆ°éœ“è™¹é’
        this.size = Math.random() * 2 + 1;
        this.pulse = Math.random() * Math.PI;
    }

    update() {
        // åŸºç¡€è‡ªè½¬
        this.angle += 0.02;
        
        // æ ¸å¿ƒåŠ¨åŠ›å­¦ï¼šå—é¼ æ ‡å¼•åŠ›å½±å“
        let targetX = Math.cos(this.angle) * this.distFromCenter;
        let targetZ = Math.sin(this.angle) * this.distFromCenter;
        
        // è®¡ç®— 2D æŠ•å½±ä½ç½®ç”¨äºäº’åŠ¨æ£€æµ‹
        const scale = PROJECTION_DIST / (PROJECTION_DIST + targetZ + 250);
        const screenX = targetX * scale + W / 2;
        const screenY = this.y3d * scale + H * 0.55;

        const dx = mouse.x - screenX;
        const dy = mouse.y - screenY;
        const dist = Math.sqrt(dx*dx + dy*dy);

        if (mouse.active && dist < 150) {
            const force = (150 - dist) / 150;
            this.angle += force * 0.1; // é è¿‘æ‰‹æŒ‡æ—‹è½¬åŠ å¿«
            this.size = (Math.random() * 3 + 2) * (1 + force);
        } else {
            this.size = Math.max(this.size * 0.95, 1.5);
        }

        // 3D è½¬æ¢
        this.rotationAngle = rotation + this.angle;
        this.x3d = Math.cos(this.rotationAngle) * this.distFromCenter;
        this.z3d = Math.sin(this.rotationAngle) * this.distFromCenter;
    }

    draw() {
        const scale = PROJECTION_DIST / (PROJECTION_DIST + this.z3d + 250);
        const x2d = this.x3d * scale + W / 2;
        const y2d = this.y3d * scale + H * 0.55;

        const alpha = Math.min(1, scale * 1.2);
        const glow = Math.sin(Date.now() * 0.005 + this.id) * 0.5 + 0.5;

        ctx.beginPath();
        // é¢œè‰²ï¼šæŒ‡å°–é è¿‘æ—¶å˜ç™½ï¼Œå¹³æ—¶ä¸ºé’è“æ¸å˜
        const finalHue = mouse.active ? this.hue + glow * 50 : this.hue;
        ctx.fillStyle = `hsla(${finalHue}, 100%, ${70 + glow * 30}%, ${alpha})`;
        
        // æ ¸å¿ƒå‘å…‰ç‚¹
        ctx.arc(x2d, y2d, this.size * scale, 0, Math.PI * 2);
        ctx.fill();

        // å¤–å›´è¾‰å…‰ (Bloom)
        if (glow > 0.8 || mouse.active) {
            ctx.beginPath();
            ctx.globalAlpha = 0.2 * glow;
            ctx.arc(x2d, y2d, this.size * scale * 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
        }
    }
}

// åˆå§‹åŒ–
for (let i = 0; i < COUNT; i++) particles.push(new Particle(i));

function drawStar() {
    const starY = -290;
    const scale = PROJECTION_DIST / (PROJECTION_DIST + 250);
    const y2d = starY * scale + H * 0.55;
    
    ctx.save();
    ctx.translate(W / 2, y2d);
    ctx.rotate(Date.now() * 0.001);
    ctx.shadowBlur = 30;
    ctx.shadowColor = "#0ff";
    ctx.fillStyle = "#fff";
    ctx.font = "45px serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("ğŸ’ ", 0, 0); // ä½¿ç”¨æ›´å…·ç§‘æŠ€æ„Ÿçš„æ˜Ÿæ ¸
    ctx.restore();
}

function animate() {
    // å…³é”®ï¼šä¸è¦æ¸…ç©ºæ•´ä¸ªç”»å¸ƒï¼Œè€Œæ˜¯è¦†ç›–ä¸€å±‚æé€æ˜çš„é»‘ï¼Œäº§ç”Ÿä¸æ»‘æ‹–å°¾
    ctx.globalCompositeOperation = "source-over";
    ctx.fillStyle = "rgba(0, 0, 0, 0.08)";
    ctx.fillRect(0, 0, W, H);

    rotation += 0.005;

    // å åŠ æ¨¡å¼ï¼šè®©é¢œè‰²èåˆäº§ç”Ÿæå…‰æ„Ÿ
    ctx.globalCompositeOperation = "lighter";

    particles.forEach(p => {
        p.update();
        p.draw();
    });

    drawStar();
    requestAnimationFrame(animate);
}

animate();
</script>
</body>
</html>
